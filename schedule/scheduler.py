from collections.abc import Hashable
import datetime
import functools
import logging
import random
import re
import time
import threading
import concurrent.futures
from typing import Set, List, Optional, Callable, Union

from .exceptions import ScheduleError, ScheduleValueError, IntervalError, CancelJob
from .job import Job

logger = logging.getLogger("schedule")


class Scheduler:
    """
    Objects instantiated by the :class:`Scheduler <Scheduler>` are
    factories to create jobs, keep record of scheduled jobs and
    handle their execution.
    """

    def __init__(self, max_workers: Optional[int] = None) -> None:
        self.jobs: List[Job] = []
        self._lock = threading.RLock()
        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)

    def run_pending(self) -> None:
        """
        Run all jobs that are scheduled to run.

        Please note that it is *intended behavior that run_pending()
        does not run missed jobs*. For example, if you've registered a job
        that should run every minute and you only call run_pending()
        in one hour increments then your job won't be run 60 times in
        between but only once.
        """
        with self._lock:
            runnable_jobs = (job for job in self.jobs if job.should_run)
            jobs_to_run = sorted(runnable_jobs)
        for job in jobs_to_run:
            self._run_job(job)

    def run_all(self, delay_seconds: int = 0) -> None:
        """
        Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time.

        :param delay_seconds: A delay added between every executed job
        """
        with self._lock:
            jobs_to_run = self.jobs[:]
            logger.debug(
                "Running *all* %i jobs with %is delay in between",
                len(jobs_to_run),
                delay_seconds,
            )
        for job in jobs_to_run:
            self._run_job(job)
            time.sleep(delay_seconds)

    def get_jobs(self, tag: Optional[Hashable] = None) -> List[Job]:
        """
        Gets scheduled jobs marked with the given tag, or all jobs
        if tag is omitted.

        :param tag: An identifier used to identify a subset of
                    jobs to retrieve
        """
        with self._lock:
            if tag is None:
                return self.jobs[:]
            else:
                return [job for job in self.jobs if tag in job.tags]

    def clear(self, tag: Optional[Hashable] = None) -> None:
        """
        Deletes scheduled jobs marked with the given tag, or all jobs
        if tag is omitted.

        :param tag: An identifier used to identify a subset of
                    jobs to delete
        """
        with self._lock:
            if tag is None:
                logger.debug("Deleting *all* jobs")
                del self.jobs[:]
            else:
                logger.debug('Deleting all jobs tagged "%s"', tag)
                self.jobs[:] = (job for job in self.jobs if tag not in job.tags)

    def cancel_job(self, job: Job) -> None:
        """
        Delete a scheduled job.

        :param job: The job to be unscheduled
        """
        with self._lock:
            try:
                logger.debug('Cancelling job "%s"', str(job))
                self.jobs.remove(job)
            except ValueError:
                logger.debug('Cancelling not-scheduled job "%s"', str(job))

    def every(self, interval: int = 1) -> Job:
        """
        Schedule a new periodic job.

        :param interval: A quantity of a certain time unit
        :return: An unconfigured :class:`Job <Job>`
        """
        job = Job(interval, self)
        return job

    def _run_job(self, job: Job) -> None:
        def _job_wrapper():
            try:
                ret = job.run()
                if isinstance(ret, CancelJob) or ret is CancelJob:
                    self.cancel_job(job)
            except Exception as e:
                logger.error(f"Error executing job {job}: {e}")
        self._executor.submit(_job_wrapper)

    def get_next_run(
        self, tag: Optional[Hashable] = None
    ) -> Optional[datetime.datetime]:
        """
        Datetime when the next job should run.

        :param tag: Filter the next run for the given tag parameter

        :return: A :class:`~datetime.datetime` object
                 or None if no jobs scheduled
        """
        with self._lock:
            if not self.jobs:
                return None
            jobs_filtered = self.get_jobs(tag)
            if not jobs_filtered:
                return None
            return min(jobs_filtered).next_run

    next_run = property(get_next_run)

    @property
    def idle_seconds(self) -> Optional[float]:
        """
        :return: Number of seconds until
                 :meth:`next_run <Scheduler.next_run>`
                 or None if no jobs are scheduled
        """
        with self._lock:
            if not self.next_run:
                return None
            return (self.next_run - datetime.datetime.now()).total_seconds()

    def shutdown(self, wait: bool = True) -> None:
        """
        Shutdown the thread pool executor.

        :param wait: If True, wait for all running tasks to complete before shutting down.
        """
        self._executor.shutdown(wait=wait)
